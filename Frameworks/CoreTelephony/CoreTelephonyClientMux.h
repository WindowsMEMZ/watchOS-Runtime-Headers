//
//   Generated by https://github.com/blacktop/ipsw (Version: 3.1.454, BuildTime: 2024-02-08T22:07:34Z)
//
//    - LC_BUILD_VERSION:  Platform: watchOSSimulator, MinOS: 10.2, SDK: 10.2, Tool: ld (902.8)
//    - LC_SOURCE_VERSION: 11207.0.0.0.0
//
#ifndef CoreTelephonyClientMux_h
#define CoreTelephonyClientMux_h
@import Foundation;

#include "FrameworkCache.h"
#include "MuxNotificationSink.h"
#include "MuxNotificationSinkDelegate-Protocol.h"

@class NSError, NSSet, NSXPCConnection, NSXPCListenerEndpoint;
@protocol {map<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>, std::less<__CTAssertionType *>, std::allocator<std::pair<__CTAssertionType *const, std::pair<dispatch::queue, void (^)(NSError *)>>>>="__tree_"{__tree<std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, std::__map_value_compare<__CTAssertionType *, std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, std::less<__CTAssertionType *>>, std::allocator<std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<__CTAssertionType *, std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, std::less<__CTAssertionType *>>>="__value_"Q}}}, {map<__unsafe_unretained id, (anonymous namespace)::DelegateContext, std::less<__unsafe_unretained id>, std::allocator<std::pair<const __unsafe_unretained id, (anonymous namespace)::DelegateContext>>>="__tree_"{__tree<std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::__map_value_compare<__unsafe_unretained id, std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::less<__unsafe_unretained id>>, std::allocator<std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<__unsafe_unretained id, std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::less<__unsafe_unretained id>>>="__value_"Q}}};

@interface CoreTelephonyClientMux : NSObject<MuxNotificationSinkDelegate> {
  /* instance variables */
  struct map<__unsafe_unretained id, (anonymous namespace)::DelegateContext, std::less<__unsafe_unretained id>, std::allocator<std::pair<const __unsafe_unretained id, (anonymous namespace)::DelegateContext>>> { struct __tree<std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::__map_value_compare<__unsafe_unretained id, std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::less<__unsafe_unretained id>>, std::allocator<std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>>> { void *__begin_node_; struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, void *>>> { struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __value_; } __pair1_; struct __compressed_pair<unsigned long, std::__map_value_compare<__unsafe_unretained id, std::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::less<__unsafe_unretained id>>> { unsigned long long __value_; } __pair3_; } __tree_; } _delegates;
  NSSet *_currentSelectorSet;
  struct map<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>, std::less<__CTAssertionType *>, std::allocator<std::pair<__CTAssertionType *const, std::pair<dispatch::queue, void (^)(NSError *)>>>> { struct __tree<std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, std::__map_value_compare<__CTAssertionType *, std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, std::less<__CTAssertionType *>>, std::allocator<std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>>> { void *__begin_node_; struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, void *>>> { struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __value_; } __pair1_; struct __compressed_pair<unsigned long, std::__map_value_compare<__CTAssertionType *, std::__value_type<__CTAssertionType *, std::pair<dispatch::queue, void (^)(NSError *)>>, std::less<__CTAssertionType *>>> { unsigned long long __value_; } __pair3_; } __tree_; } _clientCallback;
  FrameworkCache *_cache;
}

@property (retain, nonatomic) NSXPCConnection *connection;
@property (nonatomic) struct queue { struct object { struct dispatch_object_s * x0; } x0; } xpcQueue;
@property (retain, nonatomic) NSXPCListenerEndpoint *endpoint;
@property (retain, nonatomic) MuxNotificationSink *notificationSink;
@property (retain, nonatomic) NSError *reconnectError;

/* instance methods */
- (id)init;
- (id)initWithSink:(id)sink;
- (id)initWithEndpoint:(id)endpoint sink:(id)sink;
- (void)dealloc;
- (void)addDelegate:(id)delegate queue:(struct queue { struct object { struct dispatch_object_s * x0; } x0; })queue;
- (void)removeDelegate:(id)delegate;
- (void)sink:(id)sink handleNotification:(id)notification;
- (id)proxyWithQueue:(struct queue { struct object { struct dispatch_object_s * x0; } x0; })queue errorHandler:(id /* block */)handler;
- (id)synchronousProxyWithErrorHandler:(id /* block */)handler;
- (id)cachedValueForSelector:(SEL)selector;
- (void)cacheValue:(id)value forSelector:(SEL)selector;
- (id)proxyWithErrorHandler_sync:(id /* block */)handler_sync;
- (void)_computeNotificationSetForced_sync;
- (void)_computeNotificationSetForced_sync:(id /* block */)forced_sync;
- (void)_computeNotificationSet_sync:(id /* block */)set_sync;
- (void)_computeNotificationSet_sync:(BOOL)set_sync completion:(id /* block */)completion;
- (void)_registerForNotifications_sync:(id)notifications_sync shouldForce:(BOOL)force completion:(id /* block */)completion;
- (void)_setReconnectError_sync:(id)error_sync;
- (void)_connect_sync;
- (void)_initializeConnection_sync;
- (void)_ensureConnectionSetup_sync;
- (void)_ensureConnectionSetup_sync:(BOOL)setup_sync;
- (id)_connection;
- (void)_sendConnectionInvalidatedNotification_sync:(id)notification_sync;
- (void)removeAssertionForInvalidationNotification:(struct __CTAssertionType { struct __CFRuntimeBase { unsigned long long x0; atomic  x1; unsigned long long x2; } x0; id x1; id x2; int x3; } *)notification;
- (unsigned long long)_getAssertionTypeId;
- (struct __CTAssertionType { struct __CFRuntimeBase { unsigned long long x0; atomic  x1; unsigned long long x2; } x0; id x1; id x2; int x3; } *)createCTAssertionForConnectionType:(int)type allocator:(struct __CFAllocator *)allocator proxy:(id)proxy;
- (void)registerBlockForInvalidationNotification:(struct __CTAssertionType { struct __CFRuntimeBase { unsigned long long x0; atomic  x1; unsigned long long x2; } x0; id x1; id x2; int x3; } *)notification callbackQueue:(struct queue { struct object { struct dispatch_object_s * x0; } x0; })queue callback:(id /* block */)callback;
@end

#endif /* CoreTelephonyClientMux_h */
