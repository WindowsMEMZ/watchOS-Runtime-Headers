//
//   Generated by https://github.com/blacktop/ipsw (Version: 3.1.454, BuildTime: 2024-02-08T22:07:34Z)
//
//    - LC_BUILD_VERSION:  Platform: watchOSSimulator, MinOS: 10.2, SDK: 10.2, Tool: ld (902.8)
//    - LC_SOURCE_VERSION: 417.0.4.0.0
//
#ifndef NISession_h
#define NISession_h
@import Foundation;

#include "NICarKeyEventNotifier.h"
#include "NIConfiguration.h"
#include "NIDevicePresenceNotifier.h"
#include "NIDiscoveryToken.h"
#include "NIExportedObjectForwarder.h"
#include "NIFindingNotifier.h"
#include "NIServerConnection.h"
#include "UWBSessionDelegateProxyProtocol-Protocol.h"

@class NSDate, NSDictionary, NSError, NSString, NSUUID;
@protocol NIInternalSessionDelegate, NISessionDelegate, OS_dispatch_queue, OS_dispatch_semaphore, OS_os_log, {atomic<bool>="__a_"{__cxx_atomic_impl<bool, std::__cxx_atomic_base_impl<bool>>="__a_value"AB}}, {vector<UWBSessionInterruptionBookkeeping, std::allocator<UWBSessionInterruptionBookkeeping>>="__begin_"^{UWBSessionInterruptionBookkeeping}"__end_"^{UWBSessionInterruptionBookkeeping}"__end_cap_"{__compressed_pair<UWBSessionInterruptionBookkeeping *, std::allocator<UWBSessionInterruptionBookkeeping>>="__value_"^{UWBSessionInterruptionBookkeeping}}};

@interface NISession : NSObject<UWBSessionDelegateProxyProtocol> {
  /* instance variables */
  NSObject<OS_dispatch_queue> *_queue;
  NSUUID *_internalID;
  NIServerConnection *_connection;
  NIExportedObjectForwarder *_exportedObjectForwarder;
  NIConfiguration *_currentConfiguration;
  NSObject<OS_dispatch_semaphore> *_discoveryTokenSemaphore;
  struct vector<UWBSessionInterruptionBookkeeping, std::allocator<UWBSessionInterruptionBookkeeping>> { struct UWBSessionInterruptionBookkeeping *__begin_; struct UWBSessionInterruptionBookkeeping *__end_; struct __compressed_pair<UWBSessionInterruptionBookkeeping *, std::allocator<UWBSessionInterruptionBookkeeping>> { struct UWBSessionInterruptionBookkeeping *__value_; } __end_cap_; } _interruptions;
  struct atomic<bool> { struct __cxx_atomic_impl<bool, std::__cxx_atomic_base_impl<bool>> { atomic  __a_value; BOOL x0; } __a_; } _readyForCallbacks;
  NSObject<OS_os_log> *_log;
  double _startTime;
  double _duration;
  BOOL _updatedNearbyObjects;
  unsigned long long _connectionOptions;
  struct atomic<bool> { struct __cxx_atomic_impl<bool, std::__cxx_atomic_base_impl<bool>> { atomic  __a_value; BOOL x0; } __a_; } _isObserverSession;
  NSDate *_lastObjectUpdateLogTime;
  struct NearbyObjectUpdateLogging { int totalUpdates; int totalObjects; int objectsWithDistance; int objectsWithHorizontalAngle; float firstDistance; float lastDistance; float minDistance; float maxDistance; float firstHorizontalAngleRad; float lastHorizontalAngleRad; } _objectUpdateLogging;
}

@property (readonly) long long motionState;
@property (readonly) BOOL preciseRangingAllowed;
@property (readonly) BOOL extendedDistanceMeasurementAllowed;
@property long long rangingPriorityPolicy;
@property (readonly) BOOL rangingLimitExceeded;
@property (readonly) NICarKeyEventNotifier *carKeyEventNotifier;
@property (readonly) NIDevicePresenceNotifier *devicePresenceNotifier;
@property (readonly) NIFindingNotifier *findingNotifier;
@property int internalState;
@property (retain) NSError *invalidationError;
@property (retain) NSDictionary *activationResponse;
@property (weak) NSObject<NIInternalSessionDelegate> *internalDelegate;
@property (weak, nonatomic) NSObject<NISessionDelegate> *delegate;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *delegateQueue;
@property (readonly, copy, nonatomic) NIDiscoveryToken *discoveryToken;
@property (readonly, copy, nonatomic) NIConfiguration *configuration;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;

/* class methods */
+ (id)_localDeviceLogger;
+ (void)setAsyncLocalDeviceInteractableDiscoveryTokens:(id)tokens completion:(id /* block */)completion;
+ (void)getAsyncInteractableDiscoveryTokens:(id /* block */)tokens;
+ (void)getAsyncActivelyInteractingDiscoveryTokens:(id /* block */)tokens;
+ (id)setLocalDeviceCanInteract:(BOOL)interact withDiscoveryTokens:(id)tokens;
+ (id)setLocalDeviceDebugParameters:(id)parameters;
+ (id)setLocalDeviceInteractableDiscoveryTokens:(id)tokens;
+ (id)interactableDiscoveryTokens;
+ (id)activelyInteractingDiscoveryTokens;
+ (id)localDevicePrintableState;
+ (id)generateFindingDiscoveryToken;
+ (id)generateFindingDiscoveryTokenWithSharedSecret:(id)secret;
+ (id)generateFindingDiscoveryTokenWithIdentityResolvingKey:(id)key;
+ (id)generateBluetoothDeviceTokenWithPublicAddress:(id)address IRK:(id)irk;
+ (id)internalDeviceCapabilities;
+ (id)observerSession;
+ (id)cachedPlatformCapabilities;
+ (void)setCachedPlatformCapabilities:(id)capabilities;
+ (BOOL)_supportedPlatform:(id)platform;
+ (void)_queryAndCacheCapabilities;
+ (BOOL)isSupported;
+ (id)deviceCapabilities;

/* instance methods */
- (void)_provideTruthTag:(id)tag;
- (void)processVisionInput:(id)input;
- (void)updateResponderDeviceIdentifier:(id)identifier completionHandler:(id /* block */)handler;
- (id)_setURSKTTL:(unsigned long long)urskttl;
- (void)processDCKMessage:(id)dckmessage responseCallback:(id /* block */)callback;
- (void)processBluetoothEventWithType:(long long)type btcClockTicks:(unsigned long long)ticks eventCounter:(unsigned long long)counter;
- (void)processBluetoothEventWithType:(long long)type btcClockTicks:(unsigned long long)ticks;
- (id)deleteURSKs;
- (id)_setDebugURSK:(id)ursk transactionIdentifier:(unsigned int)identifier;
- (BOOL)isRangingLimitExceeded;
- (void)_addObject:(id)object;
- (void)_removeObject:(id)object;
- (void)_addRegionPredicate:(id)predicate;
- (void)_removeRegionPredicate:(id)predicate;
- (BOOL)isPreciseRangingAllowed;
- (BOOL)isExtendedDistanceMeasurementAllowed;
- (id)_initAndConnectToServerWithOptions:(unsigned long long)options;
- (void)_osLogNearbyObjectUpdate:(id)update;
- (void)_logTime;
- (void)_logDurationAndSubmit:(BOOL)submit;
- (void)_submitErrorMetric:(id)metric;
- (BOOL)_isInternalClient;
- (id)init;
- (void)runWithConfiguration:(id)configuration;
- (void)pause;
- (void)invalidate;
- (void)setARSession:(id)arsession;
- (void)_setARSessionInternal:(id)internal;
- (struct { x0[4] })worldTransformForObject:(id)object;
- (BOOL)isEqual:(id)equal;
- (void)setConfigurationForTesting:(id)testing;
- (id)getInternalIdentifier;
- (id)getInternalLogObject;
- (id)getInternalConnectionQueue;
- (void)_serverConnectionInvalidated;
- (void)_serverConnectionInterrupted;
- (id)_remoteObject;
- (id)_synchronousRemoteObject;
- (void)didRemoveNearbyObjects:(id)objects withReason:(unsigned long long)reason;
- (void)didUpdateNearbyObjects:(id)objects;
- (void)uwbSessionDidFailWithError:(id)error;
- (void)uwbSessionDidInvalidateWithError:(id)error;
- (void)uwbSessionInterruptedWithReason:(long long)reason timestamp:(double)timestamp;
- (void)uwbSessionInterruptionReasonEnded:(long long)ended timestamp:(double)timestamp;
- (void)didUpdateLocalDiscoveryToken:(id)token;
- (void)didReceiveRangingAuthRecommendation:(BOOL)recommendation forObject:(id)object;
- (void)didDiscoverNearbyObject:(id)object;
- (void)object:(id)object didUpdateRegion:(id)region previousRegion:(id)region;
- (void)didUpdateMotionState:(long long)state;
- (void)didUpdateHomeDeviceUWBRangingAvailability:(BOOL)availability;
- (void)relayDCKMessage:(id)dckmessage;
- (void)didUpdateHealthStatus:(long long)status;
- (void)didGenerateShareableConfigurationData:(id)data forObject:(id)object;
- (void)didUpdateAlgorithmState:(id)state forObject:(id)object;
- (void)_invalidateSessionAndNotifyError:(id)error;
- (void)_interruptSessionWithInternalReason:(long long)reason cachedInterruption:(BOOL)interruption;
- (void)_reinterruptSessionWithCachedInterruption;
- (void)_invalidateInternal;
- (void)_handleActivationError:(id)error;
- (void)_handleActivationSuccess:(id)success;
- (void)_handleRunSessionError:(id)error;
- (void)_handleRunSessionSuccess;
- (void)_handlePauseSessionError:(id)error;
- (void)_handlePauseSessionSuccess;
- (void)_performBlockOnDelegateQueue:(id /* block */)queue ifRespondsToSelector:(SEL)selector;
- (void)_performBlockOnDelegateQueue:(id /* block */)queue ifRespondsToSelector:(SEL)selector evenIfNotRunning:(BOOL)running;
- (id)_verifyError:(id)error;
- (void)_notifyDidInvalidateWithError:(id)error;
- (id)_getSessionFailureError;
@end

#endif /* NISession_h */
